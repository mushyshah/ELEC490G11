<!doctype html>
<html ng-app="mean.d3">
<head>
    <meta content="width=320px, initial-scale=1, user-scalable=yes" name="viewport" />
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script>

    <link type="text/css" rel="stylesheet" href="/d3/assets/css/stylesheet.css" />	
  <!-- scripts -->
  <script type="text/javascript" src="/d3/assets/scripts/custom.js"></script>
  <script src="/d3/assets/scripts/d3.js"></script>
  <script src="/d3/assets/scripts/radarDraw.js"></script>

	<meta charset="utf-8">
		<meta name="apple-mobile-web-app-capable" content="yes" />
	<style>
		#nav {
				background-color:#05203B;
				color:white; 
				text-align:left;
				font-family:calibri;
			}
			
			#power-gauge g.arc {
			fill: steelblue;
			}
			
			#power-gauge g.pointer {
			fill: #e85116;
			stroke: #b64011;
			}
			
			#power-gauge g.label text {
			text-anchor: middle;
			font-size: 14px;
			font-weight: bold;
			fill: #666;
			}
	</style>
</head>
<body>
 
    <!-- Your Content Here -->
	<br>
	<div id="nav" >
			<p style = "padding-left: 50px;"><b>Detailed Results</b></p>
	</div>
	<p style = "padding-left: 50px; padding-right:50px; padding:20px;">This survey evaluated your learning strategies on five different
	dimension. Please take a look at each of them and reflect on what
	the results mean to you. We encourage you to leave feedback on your
	results to let us know what you think about what we have reported.</p>
	<br>
	<div style="text-align:center">
		<div class="container" ng-controller="D3Controller as radar"> <!-- changed body to div -->
		<!-- main content -->
		<div class="main container">
			<div id="power-gauge">
			<script>
				var gauge1 = function(container, configuration) {
					var that = {};
					var config = {
						size						: 200,
						clipWidth					: 200,
						clipHeight					: 110,
						ringInset					: 20,
						ringWidth					: 20,
						
						pointerWidth				: 10,
						pointerTailLength			: 5,
						pointerHeadLengthPercent	: 0.9,
						
						minValue					: 0,
						maxValue					: 4,
						
						minAngle					: -90,
						maxAngle					: 90,
						
						transitionMs				: 750,
						
						majorTicks					: 4,
						labelFormat					: d3.format(',g'),
						labelInset					: 10,
						
						arcColorFn					: d3.interpolateHsl(d3.rgb('#ff0000'), d3.rgb('#ffcccc'))
					};
					var range = undefined;
					var r = undefined;
					var pointerHeadLength = undefined;
					var value = 0;
					
					var svg = undefined;
					var arc = undefined;
					var scale = undefined;
					var ticks = undefined;
					var tickData = undefined;
					var pointer = undefined;
					
					var donut = d3.layout.pie();
					
					function deg2rad(deg) {
						return deg * Math.PI / 180;
					}
					
					function newAngle(d) {
						var ratio = scale(d);
						var newAngle = config.minAngle + (ratio * range);
						return newAngle;
					}
					
					function configure(configuration) {
						var prop = undefined;
						for ( prop in configuration ) {
							config[prop] = configuration[prop];
						}
						
						range = config.maxAngle - config.minAngle;
						r = config.size / 2;
						pointerHeadLength = Math.round(r * config.pointerHeadLengthPercent);
						
						// a linear scale that maps domain values to a percent from 0..1
						scale = d3.scale.linear()
						.range([0,1])
						.domain([config.minValue, config.maxValue]);
						
						ticks = scale.ticks(config.majorTicks);
						tickData = d3.range(config.majorTicks).map(function() {return 1/config.majorTicks;});
						
						arc = d3.svg.arc()
						.innerRadius(r - config.ringWidth - config.ringInset)
						.outerRadius(r - config.ringInset)
						.startAngle(function(d, i) {
							var ratio = d * i;
							return deg2rad(config.minAngle + (ratio * range));
						})
						.endAngle(function(d, i) {
							var ratio = d * (i+1);
							return deg2rad(config.minAngle + (ratio * range));
						});
					}
					that.configure = configure;
					
					function centerTranslation() {
						return 'translate('+r +','+ r +')';
					}
					
					function isRendered() {
						return (svg !== undefined);
					}
					that.isRendered = isRendered;
					
					function render(newValue) {
						svg = d3.select(container)
						.append('svg:svg')
						.attr('class', 'gauge1')
						.attr('width', config.clipWidth)
						.attr('height', config.clipHeight);
						
						var centerTx = centerTranslation();
						
						var arcs = svg.append('g')
						.attr('class', 'arc')
						.attr('transform', centerTx);
						
						arcs.selectAll('path')
						.data(tickData)
						.enter().append('path')
						.attr('fill', function(d, i) {
							return config.arcColorFn(d * i);
						})
						.attr('d', arc);
						
						var lineData = [ [config.pointerWidth / 2, 0], 
						[0, -pointerHeadLength],
						[-(config.pointerWidth / 2), 0],
						[0, config.pointerTailLength],
						[config.pointerWidth / 2, 0] ];
						var pointerLine = d3.svg.line().interpolate('monotone');
						var pg = svg.append('g').data([lineData])
						.attr('class', 'pointer')
						.attr('transform', centerTx);
						
						pointer = pg.append('path')
						.attr('d', pointerLine/*function(d) { return pointerLine(d) +'Z';}*/ )
						.attr('transform', 'rotate(' +config.minAngle +')');
						
						update(newValue === undefined ? 0 : newValue);
					}
					that.render = render;
					
					function update(newValue, newConfiguration) {
						if ( newConfiguration  !== undefined) {
							configure(newConfiguration);
						}
						var ratio = scale(newValue);
						var newAngle = config.minAngle + (ratio * range);
						pointer.transition()
						.duration(config.transitionMs)
						.ease('elastic')
						.attr('transform', 'rotate(' +newAngle +')');
					}
					that.update = update;
					
					configure(configuration);
					
					return that;
				};
			</script>
			<script>
				var gauge2 = function(container, configuration) {
					var that = {};
					var config = {
						size						: 200,
						clipWidth					: 200,
						clipHeight					: 110,
						ringInset					: 20,
						ringWidth					: 20,
						
						pointerWidth				: 10,
						pointerTailLength			: 5,
						pointerHeadLengthPercent	: 0.9,
						
						minValue					: 0,
						maxValue					: 4,
						
						minAngle					: -90,
						maxAngle					: 90,
						
						transitionMs				: 750,
						
						majorTicks					: 4,
						labelFormat					: d3.format(',g'),
						labelInset					: 10,
						
						arcColorFn					: d3.interpolateHsl(d3.rgb('#99ccff'), d3.rgb('#000099'))
					};
					var range = undefined;
					var r = undefined;
					var pointerHeadLength = undefined;
					var value = 0;
					
					var svg = undefined;
					var arc = undefined;
					var scale = undefined;
					var ticks = undefined;
					var tickData = undefined;
					var pointer = undefined;
					
					var donut = d3.layout.pie();
					
					function deg2rad(deg) {
						return deg * Math.PI / 180;
					}
					
					function newAngle(d) {
						var ratio = scale(d);
						var newAngle = config.minAngle + (ratio * range);
						return newAngle;
					}
					
					function configure(configuration) {
						var prop = undefined;
						for ( prop in configuration ) {
							config[prop] = configuration[prop];
						}
						
						range = config.maxAngle - config.minAngle;
						r = config.size / 2;
						pointerHeadLength = Math.round(r * config.pointerHeadLengthPercent);
						
						// a linear scale that maps domain values to a percent from 0..1
						scale = d3.scale.linear()
						.range([0,1])
						.domain([config.minValue, config.maxValue]);
						
						ticks = scale.ticks(config.majorTicks);
						tickData = d3.range(config.majorTicks).map(function() {return 1/config.majorTicks;});
						
						arc = d3.svg.arc()
						.innerRadius(r - config.ringWidth - config.ringInset)
						.outerRadius(r - config.ringInset)
						.startAngle(function(d, i) {
							var ratio = d * i;
							return deg2rad(config.minAngle + (ratio * range));
						})
						.endAngle(function(d, i) {
							var ratio = d * (i+1);
							return deg2rad(config.minAngle + (ratio * range));
						});
					}
					that.configure = configure;
					
					function centerTranslation() {
						return 'translate('+r +','+ r +')';
					}
					
					function isRendered() {
						return (svg !== undefined);
					}
					that.isRendered = isRendered;
					
					function render(newValue) {
						svg = d3.select(container)
						.append('svg:svg')
						.attr('class', 'gauge2')
						.attr('width', config.clipWidth)
						.attr('height', config.clipHeight);
						
						var centerTx = centerTranslation();
						
						var arcs = svg.append('g')
						.attr('class', 'arc')
						.attr('transform', centerTx);
						
						arcs.selectAll('path')
						.data(tickData)
						.enter().append('path')
						.attr('fill', function(d, i) {
							return config.arcColorFn(d * i);
						})
						.attr('d', arc);
						
						var lineData = [ [config.pointerWidth / 2, 0], 
						[0, -pointerHeadLength],
						[-(config.pointerWidth / 2), 0],
						[0, config.pointerTailLength],
						[config.pointerWidth / 2, 0] ];
						var pointerLine = d3.svg.line().interpolate('monotone');
						var pg = svg.append('g').data([lineData])
						.attr('class', 'pointer')
						.attr('transform', centerTx);
						
						pointer = pg.append('path')
						.attr('d', pointerLine/*function(d) { return pointerLine(d) +'Z';}*/ )
						.attr('transform', 'rotate(' +config.minAngle +')');
						
						update(newValue === undefined ? 0 : newValue);
					}
					that.render = render;
					
					function update(newValue, newConfiguration) {
						if ( newConfiguration  !== undefined) {
							configure(newConfiguration);
						}
						var ratio = scale(newValue);
						var newAngle = config.minAngle + (ratio * range);
						pointer.transition()
						.duration(config.transitionMs)
						.ease('elastic')
						.attr('transform', 'rotate(' +newAngle +')');
					}
					that.update = update;
					
					configure(configuration);
					
					return that;
				};
			</script>
			<script>
				var gauge3 = function(container, configuration) {
					var that = {};
					var config = {
						size						: 200,
						clipWidth					: 200,
						clipHeight					: 110,
						ringInset					: 20,
						ringWidth					: 20,
						
						pointerWidth				: 10,
						pointerTailLength			: 5,
						pointerHeadLengthPercent	: 0.9,
						
						minValue					: 0,
						maxValue					: 4,
						
						minAngle					: -90,
						maxAngle					: 90,
						
						transitionMs				: 750,
						
						majorTicks					: 4,
						labelFormat					: d3.format(',g'),
						labelInset					: 10,
						
						arcColorFn					: d3.interpolateHsl(d3.rgb('#e8e2ca'), d3.rgb('#3e6c0a'))
					};
					var range = undefined;
					var r = undefined;
					var pointerHeadLength = undefined;
					var value = 0;
					
					var svg = undefined;
					var arc = undefined;
					var scale = undefined;
					var ticks = undefined;
					var tickData = undefined;
					var pointer = undefined;
					
					var donut = d3.layout.pie();
					
					function deg2rad(deg) {
						return deg * Math.PI / 180;
					}
					
					function newAngle(d) {
						var ratio = scale(d);
						var newAngle = config.minAngle + (ratio * range);
						return newAngle;
					}
					
					function configure(configuration) {
						var prop = undefined;
						for ( prop in configuration ) {
							config[prop] = configuration[prop];
						}
						
						range = config.maxAngle - config.minAngle;
						r = config.size / 2;
						pointerHeadLength = Math.round(r * config.pointerHeadLengthPercent);
						
						// a linear scale that maps domain values to a percent from 0..1
						scale = d3.scale.linear()
						.range([0,1])
						.domain([config.minValue, config.maxValue]);
						
						ticks = scale.ticks(config.majorTicks);
						tickData = d3.range(config.majorTicks).map(function() {return 1/config.majorTicks;});
						
						arc = d3.svg.arc()
						.innerRadius(r - config.ringWidth - config.ringInset)
						.outerRadius(r - config.ringInset)
						.startAngle(function(d, i) {
							var ratio = d * i;
							return deg2rad(config.minAngle + (ratio * range));
						})
						.endAngle(function(d, i) {
							var ratio = d * (i+1);
							return deg2rad(config.minAngle + (ratio * range));
						});
					}
					that.configure = configure;
					
					function centerTranslation() {
						return 'translate('+r +','+ r +')';
					}
					
					function isRendered() {
						return (svg !== undefined);
					}
					that.isRendered = isRendered;
					
					function render(newValue) {
						svg = d3.select(container)
						.append('svg:svg')
						.attr('class', 'gauge3')
						.attr('width', config.clipWidth)
						.attr('height', config.clipHeight);
						
						var centerTx = centerTranslation();
						
						var arcs = svg.append('g')
						.attr('class', 'arc')
						.attr('transform', centerTx);
						
						arcs.selectAll('path')
						.data(tickData)
						.enter().append('path')
						.attr('fill', function(d, i) {
							return config.arcColorFn(d * i);
						})
						.attr('d', arc);
						
						var lineData = [ [config.pointerWidth / 2, 0], 
						[0, -pointerHeadLength],
						[-(config.pointerWidth / 2), 0],
						[0, config.pointerTailLength],
						[config.pointerWidth / 2, 0] ];
						var pointerLine = d3.svg.line().interpolate('monotone');
						var pg = svg.append('g').data([lineData])
						.attr('class', 'pointer')
						.attr('transform', centerTx);
						
						pointer = pg.append('path')
						.attr('d', pointerLine/*function(d) { return pointerLine(d) +'Z';}*/ )
						.attr('transform', 'rotate(' +config.minAngle +')');
						
						update(newValue === undefined ? 0 : newValue);
					}
					that.render = render;
					
					function update(newValue, newConfiguration) {
						if ( newConfiguration  !== undefined) {
							configure(newConfiguration);
						}
						var ratio = scale(newValue);
						var newAngle = config.minAngle + (ratio * range);
						pointer.transition()
						.duration(config.transitionMs)
						.ease('elastic')
						.attr('transform', 'rotate(' +newAngle +')');
					}
					that.update = update;
					
					configure(configuration);
					
					return that;
				};
			</script>
			<script>
				var gauge4 = function(container, configuration) {
					var that = {};
					var config = {
						size						: 200,
						clipWidth					: 200,
						clipHeight					: 110,
						ringInset					: 20,
						ringWidth					: 20,
						
						pointerWidth				: 10,
						pointerTailLength			: 5,
						pointerHeadLengthPercent	: 0.9,
						
						minValue					: 0,
						maxValue					: 4,
						
						minAngle					: -90,
						maxAngle					: 90,
						
						transitionMs				: 750,
						
						majorTicks					: 4,
						labelFormat					: d3.format(',g'),
						labelInset					: 10,
						
						arcColorFn					: d3.interpolateHsl(d3.rgb('#ff9900'), d3.rgb('#ffcc99'))
					};
					var range = undefined;
					var r = undefined;
					var pointerHeadLength = undefined;
					var value = 0;
					
					var svg = undefined;
					var arc = undefined;
					var scale = undefined;
					var ticks = undefined;
					var tickData = undefined;
					var pointer = undefined;
					
					var donut = d3.layout.pie();
					
					function deg2rad(deg) {
						return deg * Math.PI / 180;
					}
					
					function newAngle(d) {
						var ratio = scale(d);
						var newAngle = config.minAngle + (ratio * range);
						return newAngle;
					}
					
					function configure(configuration) {
						var prop = undefined;
						for ( prop in configuration ) {
							config[prop] = configuration[prop];
						}
						
						range = config.maxAngle - config.minAngle;
						r = config.size / 2;
						pointerHeadLength = Math.round(r * config.pointerHeadLengthPercent);
						
						// a linear scale that maps domain values to a percent from 0..1
						scale = d3.scale.linear()
						.range([0,1])
						.domain([config.minValue, config.maxValue]);
						
						ticks = scale.ticks(config.majorTicks);
						tickData = d3.range(config.majorTicks).map(function() {return 1/config.majorTicks;});
						
						arc = d3.svg.arc()
						.innerRadius(r - config.ringWidth - config.ringInset)
						.outerRadius(r - config.ringInset)
						.startAngle(function(d, i) {
							var ratio = d * i;
							return deg2rad(config.minAngle + (ratio * range));
						})
						.endAngle(function(d, i) {
							var ratio = d * (i+1);
							return deg2rad(config.minAngle + (ratio * range));
						});
					}
					that.configure = configure;
					
					function centerTranslation() {
						return 'translate('+r +','+ r +')';
					}
					
					function isRendered() {
						return (svg !== undefined);
					}
					that.isRendered = isRendered;
					
					function render(newValue) {
						svg = d3.select(container)
						.append('svg:svg')
						.attr('class', 'gauge4')
						.attr('width', config.clipWidth)
						.attr('height', config.clipHeight);
						
						var centerTx = centerTranslation();
						
						var arcs = svg.append('g')
						.attr('class', 'arc')
						.attr('transform', centerTx);
						
						arcs.selectAll('path')
						.data(tickData)
						.enter().append('path')
						.attr('fill', function(d, i) {
							return config.arcColorFn(d * i);
						})
						.attr('d', arc);
						
						var lineData = [ [config.pointerWidth / 2, 0], 
						[0, -pointerHeadLength],
						[-(config.pointerWidth / 2), 0],
						[0, config.pointerTailLength],
						[config.pointerWidth / 2, 0] ];
						var pointerLine = d3.svg.line().interpolate('monotone');
						var pg = svg.append('g').data([lineData])
						.attr('class', 'pointer')
						.attr('transform', centerTx);
						
						pointer = pg.append('path')
						.attr('d', pointerLine/*function(d) { return pointerLine(d) +'Z';}*/ )
						.attr('transform', 'rotate(' +config.minAngle +')');
						
						update(newValue === undefined ? 0 : newValue);
					}
					that.render = render;
					
					function update(newValue, newConfiguration) {
						if ( newConfiguration  !== undefined) {
							configure(newConfiguration);
						}
						var ratio = scale(newValue);
						var newAngle = config.minAngle + (ratio * range);
						pointer.transition()
						.duration(config.transitionMs)
						.ease('elastic')
						.attr('transform', 'rotate(' +newAngle +')');
					}
					that.update = update;
					
					configure(configuration);
					
					return that;
				};
			</script>
			<script>
				var gauge5 = function(container, configuration) {
					var that = {};
					var config = {
						size						: 200,
						clipWidth					: 200,
						clipHeight					: 110,
						ringInset					: 20,
						ringWidth					: 20,
						
						pointerWidth				: 10,
						pointerTailLength			: 5,
						pointerHeadLengthPercent	: 0.9,
						
						minValue					: 0,
						maxValue					: 4,
						
						minAngle					: -90,
						maxAngle					: 90,
						
						transitionMs				: 750,
						
						majorTicks					: 4,
						labelFormat					: d3.format(',g'),
						labelInset					: 10,
						
						arcColorFn					: d3.interpolateHsl(d3.rgb('#ffccff'), d3.rgb('#660066'))
					};
					var range = undefined;
					var r = undefined;
					var pointerHeadLength = undefined;
					var value = 0;
					
					var svg = undefined;
					var arc = undefined;
					var scale = undefined;
					var ticks = undefined;
					var tickData = undefined;
					var pointer = undefined;
					
					var donut = d3.layout.pie();
					
					function deg2rad(deg) {
						return deg * Math.PI / 180;
					}
					
					function newAngle(d) {
						var ratio = scale(d);
						var newAngle = config.minAngle + (ratio * range);
						return newAngle;
					}
					
					function configure(configuration) {
						var prop = undefined;
						for ( prop in configuration ) {
							config[prop] = configuration[prop];
						}
						
						range = config.maxAngle - config.minAngle;
						r = config.size / 2;
						pointerHeadLength = Math.round(r * config.pointerHeadLengthPercent);
						
						// a linear scale that maps domain values to a percent from 0..1
						scale = d3.scale.linear()
						.range([0,1])
						.domain([config.minValue, config.maxValue]);
						
						ticks = scale.ticks(config.majorTicks);
						tickData = d3.range(config.majorTicks).map(function() {return 1/config.majorTicks;});
						
						arc = d3.svg.arc()
						.innerRadius(r - config.ringWidth - config.ringInset)
						.outerRadius(r - config.ringInset)
						.startAngle(function(d, i) {
							var ratio = d * i;
							return deg2rad(config.minAngle + (ratio * range));
						})
						.endAngle(function(d, i) {
							var ratio = d * (i+1);
							return deg2rad(config.minAngle + (ratio * range));
						});
					}
					that.configure = configure;
					
					function centerTranslation() {
						return 'translate('+r +','+ r +')';
					}
					
					function isRendered() {
						return (svg !== undefined);
					}
					that.isRendered = isRendered;
					
					function render(newValue) {
						svg = d3.select(container)
						.append('svg:svg')
						.attr('class', 'gauge5')
						.attr('width', config.clipWidth)
						.attr('height', config.clipHeight);
						
						var centerTx = centerTranslation();
						
						var arcs = svg.append('g')
						.attr('class', 'arc')
						.attr('transform', centerTx);
						
						arcs.selectAll('path')
						.data(tickData)
						.enter().append('path')
						.attr('fill', function(d, i) {
							return config.arcColorFn(d * i);
						})
						.attr('d', arc);
						
						var lineData = [ [config.pointerWidth / 2, 0], 
						[0, -pointerHeadLength],
						[-(config.pointerWidth / 2), 0],
						[0, config.pointerTailLength],
						[config.pointerWidth / 2, 0] ];
						var pointerLine = d3.svg.line().interpolate('monotone');
						var pg = svg.append('g').data([lineData])
						.attr('class', 'pointer')
						.attr('transform', centerTx);
						
						pointer = pg.append('path')
						.attr('d', pointerLine/*function(d) { return pointerLine(d) +'Z';}*/ )
						.attr('transform', 'rotate(' +config.minAngle +')');
						
						update(newValue === undefined ? 0 : newValue);
					}
					that.render = render;
					
					function update(newValue, newConfiguration) {
						if ( newConfiguration  !== undefined) {
							configure(newConfiguration);
						}
						var ratio = scale(newValue);
						var newAngle = config.minAngle + (ratio * range);
						pointer.transition()
						.duration(config.transitionMs)
						.ease('elastic')
						.attr('transform', 'rotate(' +newAngle +')');
					}
					that.update = update;
					
					configure(configuration);
					
					return that;
				};
			</script>
			
			<script>
				function onDocumentReady() {
					var powerGauge1 = gauge1('#power-gauge', {
						size: 150,
						clipWidth: 225,
						clipHeight: 100,
						ringWidth: 30,
						maxValue: 4,
						transitionMs: 3000,
					});
					var powerGauge2 = gauge2('#power-gauge', {
						size: 150,
						clipWidth: 225,
						clipHeight: 100,
						ringWidth: 30,
						maxValue: 4,
						transitionMs: 3000,
					});
					var powerGauge3 = gauge3('#power-gauge', {
						size: 150,
						clipWidth: 225,
						clipHeight: 100,
						ringWidth: 30,
						maxValue: 4,
						transitionMs: 3000,
					});
					var powerGauge4 = gauge4('#power-gauge', {
						size: 150,
						clipWidth: 225,
						clipHeight: 100,
						ringWidth: 30,
						maxValue: 4,
						transitionMs: 3000,
					});
					var powerGauge5 = gauge5('#power-gauge', {
						size: 150,
						clipWidth: 225,
						clipHeight: 100,
						ringWidth: 30,
						maxValue: 4,
						transitionMs: 3000,
					});
					
					function updateReadings(c) {

						// $http.get('/api/surveys/gaugeData/56433548/').success(function(data) {
					 //        console.log(data);
					      
						// // just pump in random data here...
						// powerGauge1.update(data.OSS); //<-------------------------------------gauge values
						// powerGauge2.update(data.OMSS);
						// powerGauge3.update(data.LBSS);
						// powerGauge4.update(data.SESS);
						// powerGauge5.update(data.TRSS);

						powerGauge1.update(c); //<-------------------------------------gauge values
						powerGauge2.update(c);
						powerGauge3.update(c);
						powerGauge4.update(c);
						powerGauge5.update(c);
						// });
					}
									
					powerGauge1.render();
					powerGauge2.render();
					powerGauge3.render();
					powerGauge4.render();
					powerGauge5.render();
					
					// update reading values
					updateReadings();
				}
				
				// if ( !window.isLoaded ) {
				// 	window.addEventListener("load", function() {
				// 		onDocumentReady();
				// 	}, false);
				// 	} else {
				// 	onDocumentReady();
				// }

				onDocumentReady();
			</script>  
			</div>		
		</div>
	</div>
</div>
	<p style = "padding-left: 50px; padding-right:50px;">Please explore your results in more detail by clicking on the button below. You will be given a detailed description on how you scored on each dimension,
	and what that score means for you. Take the time to reflect. You will be prompted to provide feedback at the end of your results.</p>
	<br>
	<br>
	<div style = "text-align:center">
		<p>Click the link below to view your detailed results. You may also re-visit the spider diagram by clicking on the image.</p>
		<br>
		<a class="next-btn"href="selfmotivation.html">To in-depth results!</a>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<br>
		<a class="show-popup" href="#" data-showpopup="1" ><img src = "/d3/assets/img/testimg5.jpg"</img></a>
	</div>

<div class="overlay-bg">
</div>
<div class="overlay-content popup1">
    <div id="nav" >
			<p style = "padding-left: 50px;"><b>Your Results</b></p>
		</div>
		<div style = "text-align:center;">
			<div class="container" ng-controller="D3Controller as radar"> <!-- changed body to div -->
		<!-- main content -->
		<div class="main container">
			<!-- visualization -->
			<div class="visualization col-xs-7">
				<div class="visualization">
					<radar csv="radar.csv" config="radar.config"></radar>
				</div>
			</div>

		</div>
		<p style = "text-align:center; font-family:calibri">Thank you for taking the time to complete our survey!<br>
		Above is a spider diagram showing your results.
		When you are ready, please feel free to 
		examine your results in more detail.</p>
		<div style = "text-align:center;">
			<button class="close-btn">Read More</button>
		</div>
</div>
</body>
</html>